# Chess
Base classes needed to create Chess have been provided for me. I added my logger from the previous assignment to help me test and debug. I worked on Windows.

## FEN String Support
To set up the board with a given FEN string, I iterated through the string, placing pieces according to their respective characters, moving ranks whenever I encounter the "/" character, and moving file whenever I encounted a number (by however many it says). For the white pieces to appear on the correct side, I had to begin at row 7 and move down a row (up the board) each "/" character.

## Implementing King, Knight, and Pawn Movement
I used the provided Bitboard.h class, which has a helpful template iterator. When the game starts, I generate all possible moves for kings and knights from any position on the board and store those bitboards for later. I later add the relevant moves to a vector of possible moves with the functions generateKingMoves() and generateKnightMoves(). I could not do the same thing for pawns, since they have multiple different kinds of moves, so I generate those by hand using bitboards containing enemies and empty spaces. Single moves forward are calculated, for example, by shifting each pawn bit by 8 or -8 (depending on whether it's white or black and must move up or down the board). Then, I & the bitboard of empty spaces to make sure that only single moves into an open space are added. Double moves forward are calculated by taking these single moves and, if they fall in either rank ahead of the starting ranks, I shift the pawn bit another 8 or -8. For captures, I calculate left captures and right captures separately, using masks for the left and right sides of the board to make sure pawns cannot capture around the edges. Additionally, I had to modify the way that piece notation was found to rely on the bit's owner so that my state string was correct. I also had to modify how ChessSquare determines whether pieces are capturable by comparing the owners rather than xor-ing the gameTag.

## Implementing Rook, Bishop, and Queen Movement
I used the provided MagicBitboards.h file to generate the moves for rooks, bishops and queens, as well as clean up move generation for kings and knights.

## Implementing Negamax AI
I first optimized my move generation by removing all branching with a BitBoard lookup table. Eventually, I replaced the messy move generation code in Chess.cpp with the GameState class. After that, I added the necessary functions for negamax and created the piece-square tables and piece type evaluation scores used for the evaluation function (these can be found in EvaluationData.h). I used the values provided in class for this data. When I tested it out at depth 3, the AI was already playing pretty well. It's not very good at end game, though, because I didn't add any end game evaluation tables.

I should also mention that I had to modify the definitions of WHITE as 1 and BLACK as -1 because I was using 0 for WHITE and 1 for BLACK, to reflect the move order. When Professor Devine stated that we need to have BLACK and WHITE be -1 and 1, respectively, for an AI vs. AI game to work properly, I got worried mine wouldn't. Just in case, I tested an AI vs. AI game at depth 3 to see whether it would work and was happy to find that it did! Though, it looks kind of crazy because the pieces don't have a chance to finish their move animation before the next AI starts its move.
